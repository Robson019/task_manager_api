// Code generated by MockGen. DO NOT EDIT.
// Source: ./src/core/interfaces/secondary/SessionLoader.go
//
// Generated by this command:
//
//	mockgen -source=./src/core/interfaces/secondary/SessionLoader.go -destination=./src/core/services/mocks/SessionRepositoryMock.go
//

// Package mock_secondary is a generated GoMock package.
package mock_secondary

import (
	reflect "reflect"
	errors "task_manager/src/core/errors"

	uuid "github.com/google/uuid"
	gomock "go.uber.org/mock/gomock"
)

// MockSessionLoader is a mock of SessionLoader interface.
type MockSessionLoader struct {
	ctrl     *gomock.Controller
	recorder *MockSessionLoaderMockRecorder
}

// MockSessionLoaderMockRecorder is the mock recorder for MockSessionLoader.
type MockSessionLoaderMockRecorder struct {
	mock *MockSessionLoader
}

// NewMockSessionLoader creates a new mock instance.
func NewMockSessionLoader(ctrl *gomock.Controller) *MockSessionLoader {
	mock := &MockSessionLoader{ctrl: ctrl}
	mock.recorder = &MockSessionLoaderMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSessionLoader) EXPECT() *MockSessionLoaderMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockSessionLoader) Close(uID uuid.UUID) errors.Error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close", uID)
	ret0, _ := ret[0].(errors.Error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockSessionLoaderMockRecorder) Close(uID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockSessionLoader)(nil).Close), uID)
}

// RefreshTokenExists mocks base method.
func (m *MockSessionLoader) RefreshTokenExists(uID uuid.UUID, token string) (bool, errors.Error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RefreshTokenExists", uID, token)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(errors.Error)
	return ret0, ret1
}

// RefreshTokenExists indicates an expected call of RefreshTokenExists.
func (mr *MockSessionLoaderMockRecorder) RefreshTokenExists(uID, token any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RefreshTokenExists", reflect.TypeOf((*MockSessionLoader)(nil).RefreshTokenExists), uID, token)
}

// SessionExists mocks base method.
func (m *MockSessionLoader) SessionExists(uID uuid.UUID, token string) (bool, errors.Error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SessionExists", uID, token)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(errors.Error)
	return ret0, ret1
}

// SessionExists indicates an expected call of SessionExists.
func (mr *MockSessionLoaderMockRecorder) SessionExists(uID, token any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SessionExists", reflect.TypeOf((*MockSessionLoader)(nil).SessionExists), uID, token)
}

// Store mocks base method.
func (m *MockSessionLoader) Store(accountID uuid.UUID, accessToken, refreshToken string) errors.Error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Store", accountID, accessToken, refreshToken)
	ret0, _ := ret[0].(errors.Error)
	return ret0
}

// Store indicates an expected call of Store.
func (mr *MockSessionLoaderMockRecorder) Store(accountID, accessToken, refreshToken any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Store", reflect.TypeOf((*MockSessionLoader)(nil).Store), accountID, accessToken, refreshToken)
}
